\documentclass[journal,a4paper]{IEEEtran}
\usepackage{fullpage}
\usepackage{float}
\usepackage[T1]{fontenc}

\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{listings}

\begin{document}
\onecolumn

\title{COMP333: Assignment 2}
\author{James Ridey\\
44805632}
\maketitle

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  belowcaptionskip=1\baselineskip,
  frame=L,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\pagenumbering{gobble}
\hyphenation{water question questions maximum}
\section*{Question 1}
\begin{enumerate}
	\item What this invarient is saying is that for every item in the queue, it is at least 1 distance away from the head of the queue. This holds true for eveyr iteration of the BFS algorithm because of a few reasons, the first is that nodes are added onto the end of the queue, the second is that we never visit the same node twice and the third reason is that bfs always expands equally in every direction. For these three reasons nodes in the queue will always be in ascended distance.
	\item A
	\item A
\end{enumerate}

\section*{Question 2}
\begin{enumerate}
	\item For each loop of divideBasic we are subtracting b from a. For a worst case scenario this means we have something like 99999 / 1. Expressing this in the form a and b means we get $10^{L(a)}-1$ and $10^{L(b)-1}$. 

Given we are subtracting each loop iteration this means we have $\frac{10^{L(a)}-1}{10^{L(b)-1}}$ operations. And so the Big-Oh of divideBasic is 
	\begin{align*}
		&= \frac{10^{L(a)}-1}{10^{L(b)-1}} \\
		&= 10^{L(a)-(L(b)-1)} - 1 \\
		&= O(10^{L(a)-L(b)+1})
	\end{align*}
	\item A
	\item A
\end{enumerate}

\section*{Question 3}
\begin{enumerate}
	\item A
	\item A
	\item A
\end{enumerate}

\section*{Question 4}
\begin{enumerate}
	\item Loop invariant: TODO
		  For this algorithm it runs until b is zero and for every iteration of the loop we divide b by 2. So this loop runs at least $log_2(b)$ times. During the loop operation we do 2 multiplications and 2 divisions, while 1 of the multiplications and 1 of the divisions is behind an if statement in the worse case scenario (Big-Oh), if a number was simply a 1 bit repeated it would always trigger the if statement.
		  
		  So for the worse case scenario we have
		  \begin{align*}
		  	&= log_2(b)(2mul + 2div) \\
		  	&= log_2(b)(2(L(a)L(b)) + 2(L(a)(L(a)-L(b)+1))) \\
		  	&= log_2(b)(2(L(a)(L(a)+1))) \\
		  \end{align*}
	\item A
	\item A
\end{enumerate}

\section*{Question 5}
- For the time complexity of Karatsuba we first need to find out how deep the tree of the recursion will go. Using what we understand of the algorithm and how it effectively splits the numbers in half each time. The depth of the tree is $log_2(max(L(a),L(b)))$.

Then for every node of the recursion we do the following
\begin{enumerate}
	\item Call Karatsuba another three times
	\item 2 additions
	\item 2 multiplications
	\item 2 subtractions
	\item 2 lessThanOrEqual's
	\item 2 modpows - (similar time complexity to modexp)	
\end{enumerate}

This effectively means we have the time complexity of
\begin{align*}
	&= log_2(max(L(a),L(b)))\cdot \left( 3(2add+2mul+2sub+2less+2modpow) \right) \\
	&= log_2(max(L(a),L(b)))\cdot \left( 3(2add+2mul+2sub+2less+2modpow) \right) \\
\end{align*}

- In what circumstance would you expect Karatsubaâ€™s algorithm to be more efficient than the classical one?

\end{document}
